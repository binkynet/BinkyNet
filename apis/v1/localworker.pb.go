// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: localworker.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Direction of locs
type LocDirection int32

const (
	LocDirection_FORWARD LocDirection = 0
	LocDirection_REVERSE LocDirection = 1
)

var LocDirection_name = map[int32]string{
	0: "FORWARD",
	1: "REVERSE",
}

var LocDirection_value = map[string]int32{
	"FORWARD": 0,
	"REVERSE": 1,
}

func (x LocDirection) String() string {
	return proto.EnumName(LocDirection_name, int32(x))
}

func (LocDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{0}
}

// Empty message
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// Information about the local worker
type LocalWorkerInfo struct {
	// Unique identifier of the local worker
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the local worker
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Version of the local worker in semantic versioning format.
	// E.g. 1.0.4
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Uptime of the local worker in seconds.
	Uptime               int64    `protobuf:"varint,4,opt,name=uptime,proto3" json:"uptime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalWorkerInfo) Reset()         { *m = LocalWorkerInfo{} }
func (m *LocalWorkerInfo) String() string { return proto.CompactTextString(m) }
func (*LocalWorkerInfo) ProtoMessage()    {}
func (*LocalWorkerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{1}
}
func (m *LocalWorkerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalWorkerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalWorkerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalWorkerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalWorkerInfo.Merge(m, src)
}
func (m *LocalWorkerInfo) XXX_Size() int {
	return m.Size()
}
func (m *LocalWorkerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalWorkerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LocalWorkerInfo proto.InternalMessageInfo

func (m *LocalWorkerInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LocalWorkerInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *LocalWorkerInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LocalWorkerInfo) GetUptime() int64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

// Request arguments for GetPowerRequests
type PowerRequestsOptions struct {
	// If set, the network master must wait for an actual Power message
	// to confirm the state transition.
	// If not set, the network master assumes the power state is effective directly
	// after sending the message.
	ManualConfirm        bool     `protobuf:"varint,1,opt,name=manual_confirm,json=manualConfirm,proto3" json:"manual_confirm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PowerRequestsOptions) Reset()         { *m = PowerRequestsOptions{} }
func (m *PowerRequestsOptions) String() string { return proto.CompactTextString(m) }
func (*PowerRequestsOptions) ProtoMessage()    {}
func (*PowerRequestsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{2}
}
func (m *PowerRequestsOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PowerRequestsOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PowerRequestsOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PowerRequestsOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PowerRequestsOptions.Merge(m, src)
}
func (m *PowerRequestsOptions) XXX_Size() int {
	return m.Size()
}
func (m *PowerRequestsOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PowerRequestsOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PowerRequestsOptions proto.InternalMessageInfo

func (m *PowerRequestsOptions) GetManualConfirm() bool {
	if m != nil {
		return m.ManualConfirm
	}
	return false
}

// Power message contains the requested/actual state of the power on the track.
type Power struct {
	// Power on/off
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Power) Reset()         { *m = Power{} }
func (m *Power) String() string { return proto.CompactTextString(m) }
func (*Power) ProtoMessage()    {}
func (*Power) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{3}
}
func (m *Power) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Power) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Power.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Power) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Power.Merge(m, src)
}
func (m *Power) XXX_Size() int {
	return m.Size()
}
func (m *Power) XXX_DiscardUnknown() {
	xxx_messageInfo_Power.DiscardUnknown(m)
}

var xxx_messageInfo_Power proto.InternalMessageInfo

func (m *Power) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// Request arguments for GetLocRequests
type LocRequestsOptions struct {
	// If set, the network master must wait for an actual Loc message
	// to confirm the state transition.
	// If not set, the network master assumes the power state is effective directly
	// after sending the message.
	ManualConfirm        bool     `protobuf:"varint,1,opt,name=manual_confirm,json=manualConfirm,proto3" json:"manual_confirm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocRequestsOptions) Reset()         { *m = LocRequestsOptions{} }
func (m *LocRequestsOptions) String() string { return proto.CompactTextString(m) }
func (*LocRequestsOptions) ProtoMessage()    {}
func (*LocRequestsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{4}
}
func (m *LocRequestsOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocRequestsOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocRequestsOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocRequestsOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocRequestsOptions.Merge(m, src)
}
func (m *LocRequestsOptions) XXX_Size() int {
	return m.Size()
}
func (m *LocRequestsOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_LocRequestsOptions.DiscardUnknown(m)
}

var xxx_messageInfo_LocRequestsOptions proto.InternalMessageInfo

func (m *LocRequestsOptions) GetManualConfirm() bool {
	if m != nil {
		return m.ManualConfirm
	}
	return false
}

// Loc message is used to control the speed, direction & functions of a loc.
type Loc struct {
	// Addres of the loc
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Speed in steps
	Speed int32 `protobuf:"varint,2,opt,name=speed,proto3" json:"speed,omitempty"`
	// Maximum speed steps of this loc
	SpeedSteps int32 `protobuf:"varint,3,opt,name=speed_steps,json=speedSteps,proto3" json:"speed_steps,omitempty"`
	// Direction "forward|reverse"
	Direction LocDirection `protobuf:"varint,4,opt,name=direction,proto3,enum=binkynet.localworker.v1.LocDirection" json:"direction,omitempty"`
	// State of functions
	Functions            map[int32]bool `protobuf:"bytes,5,rep,name=functions,proto3" json:"functions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Loc) Reset()         { *m = Loc{} }
func (m *Loc) String() string { return proto.CompactTextString(m) }
func (*Loc) ProtoMessage()    {}
func (*Loc) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d9116c22e0c2dd1, []int{5}
}
func (m *Loc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Loc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Loc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Loc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Loc.Merge(m, src)
}
func (m *Loc) XXX_Size() int {
	return m.Size()
}
func (m *Loc) XXX_DiscardUnknown() {
	xxx_messageInfo_Loc.DiscardUnknown(m)
}

var xxx_messageInfo_Loc proto.InternalMessageInfo

func (m *Loc) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Loc) GetSpeed() int32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Loc) GetSpeedSteps() int32 {
	if m != nil {
		return m.SpeedSteps
	}
	return 0
}

func (m *Loc) GetDirection() LocDirection {
	if m != nil {
		return m.Direction
	}
	return LocDirection_FORWARD
}

func (m *Loc) GetFunctions() map[int32]bool {
	if m != nil {
		return m.Functions
	}
	return nil
}

func init() {
	proto.RegisterEnum("binkynet.localworker.v1.LocDirection", LocDirection_name, LocDirection_value)
	proto.RegisterType((*Empty)(nil), "binkynet.localworker.v1.Empty")
	proto.RegisterType((*LocalWorkerInfo)(nil), "binkynet.localworker.v1.LocalWorkerInfo")
	proto.RegisterType((*PowerRequestsOptions)(nil), "binkynet.localworker.v1.PowerRequestsOptions")
	proto.RegisterType((*Power)(nil), "binkynet.localworker.v1.Power")
	proto.RegisterType((*LocRequestsOptions)(nil), "binkynet.localworker.v1.LocRequestsOptions")
	proto.RegisterType((*Loc)(nil), "binkynet.localworker.v1.Loc")
	proto.RegisterMapType((map[int32]bool)(nil), "binkynet.localworker.v1.Loc.FunctionsEntry")
}

func init() { proto.RegisterFile("localworker.proto", fileDescriptor_4d9116c22e0c2dd1) }

var fileDescriptor_4d9116c22e0c2dd1 = []byte{
	// 553 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x6a, 0xdb, 0x4c,
	0x10, 0x8d, 0xac, 0x28, 0x89, 0xc7, 0x5f, 0x1c, 0x7f, 0x4b, 0x68, 0x4d, 0x28, 0xae, 0x6b, 0x1a,
	0x10, 0x2d, 0x95, 0x13, 0x17, 0x4a, 0xe9, 0xcf, 0x45, 0x7e, 0x9c, 0x10, 0x30, 0xb5, 0x59, 0x41,
	0x03, 0x85, 0x12, 0x64, 0x69, 0x9c, 0x2e, 0x96, 0xb5, 0xea, 0xee, 0xca, 0xc1, 0x6f, 0xd2, 0x07,
	0xe8, 0xc3, 0xf4, 0x32, 0x8f, 0x50, 0xdc, 0x17, 0x29, 0x5a, 0x5b, 0xc4, 0x29, 0xb5, 0x0c, 0xbd,
	0x9b, 0x33, 0x67, 0xce, 0xec, 0xd9, 0xd9, 0x61, 0xe1, 0xff, 0x90, 0xfb, 0x5e, 0x78, 0xc3, 0xc5,
	0x10, 0x85, 0x13, 0x0b, 0xae, 0x38, 0x79, 0xd8, 0x67, 0xd1, 0x70, 0x12, 0xa1, 0x72, 0x16, 0xb9,
	0xf1, 0x61, 0x63, 0x13, 0xac, 0xf6, 0x28, 0x56, 0x93, 0x46, 0x02, 0x3b, 0x9d, 0x94, 0xba, 0xd4,
	0xd4, 0x45, 0x34, 0xe0, 0xa4, 0x0c, 0x05, 0x16, 0x54, 0x8d, 0xba, 0x61, 0x17, 0x69, 0x81, 0x05,
	0xa4, 0x0e, 0xa5, 0x00, 0xa5, 0x2f, 0x58, 0xac, 0x18, 0x8f, 0xaa, 0x05, 0x4d, 0x2c, 0xa6, 0x48,
	0x15, 0x36, 0xc7, 0x28, 0x64, 0xca, 0x9a, 0x9a, 0xcd, 0x20, 0x79, 0x00, 0x1b, 0x49, 0xac, 0xd8,
	0x08, 0xab, 0xeb, 0x75, 0xc3, 0x36, 0xe9, 0x1c, 0x35, 0xde, 0xc3, 0x6e, 0x8f, 0xdf, 0xa0, 0xa0,
	0xf8, 0x35, 0x41, 0xa9, 0x64, 0x57, 0x37, 0x92, 0x64, 0x1f, 0xca, 0x23, 0x2f, 0x4a, 0xbc, 0xf0,
	0xca, 0xe7, 0xd1, 0x80, 0x89, 0x91, 0xf6, 0xb1, 0x45, 0xb7, 0x67, 0xd9, 0x93, 0x59, 0xb2, 0xf1,
	0x04, 0x2c, 0x2d, 0x4f, 0x4f, 0xc6, 0xc8, 0xeb, 0x87, 0x18, 0xcc, 0x0b, 0x33, 0xd8, 0x78, 0x0b,
	0xa4, 0xc3, 0xfd, 0x7f, 0xec, 0xff, 0xbd, 0x00, 0x66, 0x87, 0xfb, 0x69, 0x7b, 0x2f, 0x08, 0x04,
	0x4a, 0x39, 0x9f, 0x47, 0x06, 0xc9, 0x2e, 0x58, 0x32, 0x46, 0x0c, 0xf4, 0x38, 0x2c, 0x3a, 0x03,
	0xe4, 0x31, 0x94, 0x74, 0x70, 0x25, 0x15, 0xc6, 0x52, 0x0f, 0xc3, 0xa2, 0xa0, 0x53, 0x6e, 0x9a,
	0x21, 0x27, 0x50, 0x0c, 0x98, 0x40, 0x5f, 0x4f, 0x32, 0x1d, 0x49, 0xb9, 0xb5, 0xef, 0x2c, 0x79,
	0x24, 0xa7, 0xc3, 0xfd, 0xd3, 0xac, 0x98, 0xde, 0xe9, 0xc8, 0x05, 0x14, 0x07, 0x49, 0xa4, 0x63,
	0x59, 0xb5, 0xea, 0xa6, 0x5d, 0x6a, 0x3d, 0xcf, 0x6b, 0xe2, 0x9c, 0x65, 0xd5, 0xed, 0x48, 0x89,
	0x09, 0xbd, 0x53, 0xef, 0xbd, 0x83, 0xf2, 0x7d, 0x92, 0x54, 0xc0, 0x1c, 0xe2, 0x44, 0x5f, 0xd7,
	0xa2, 0x69, 0x98, 0x5e, 0x75, 0xec, 0x85, 0x09, 0xea, 0xab, 0x6e, 0xd1, 0x19, 0x78, 0x53, 0x78,
	0x6d, 0x3c, 0xb3, 0xe1, 0xbf, 0x45, 0x8f, 0xa4, 0x04, 0x9b, 0x67, 0x5d, 0x7a, 0x79, 0x44, 0x4f,
	0x2b, 0x6b, 0x29, 0xa0, 0xed, 0x8f, 0x6d, 0xea, 0xb6, 0x2b, 0x46, 0xeb, 0xd6, 0xd4, 0xcf, 0x91,
	0xed, 0x99, 0x8b, 0x62, 0xcc, 0x7c, 0x24, 0x3d, 0x58, 0xef, 0xb1, 0xe8, 0x9a, 0xd8, 0x79, 0xf6,
	0x17, 0x97, 0x73, 0xaf, 0xb6, 0xb4, 0x52, 0xef, 0x33, 0xf1, 0xa1, 0x72, 0x8e, 0xea, 0xde, 0x6e,
	0x91, 0x17, 0x4b, 0x35, 0x7f, 0xdb, 0xc1, 0x9c, 0x23, 0x74, 0xf9, 0x81, 0x41, 0x5c, 0xd8, 0x71,
	0xe7, 0x87, 0x1c, 0xf9, 0x2a, 0xf1, 0x42, 0x49, 0x56, 0x88, 0x56, 0xf9, 0xb6, 0x0d, 0xf2, 0x19,
	0xca, 0xe7, 0xa8, 0x16, 0x76, 0x96, 0xe4, 0x3e, 0xea, 0x9f, 0xae, 0x1f, 0xe5, 0x15, 0x1f, 0x18,
	0xa4, 0x0b, 0xdb, 0xae, 0x6e, 0x9f, 0x39, 0xce, 0x15, 0xac, 0xf6, 0x7b, 0xfc, 0xea, 0xc7, 0xb4,
	0x66, 0xdc, 0x4e, 0x6b, 0xc6, 0xcf, 0x69, 0xcd, 0xf8, 0xf6, 0xab, 0xb6, 0xf6, 0xe9, 0xe9, 0x35,
	0x53, 0x5f, 0x92, 0xbe, 0xe3, 0xf3, 0x51, 0x33, 0x53, 0x37, 0x8f, 0xd3, 0xe0, 0x03, 0xaa, 0xa6,
	0x17, 0x33, 0xd9, 0x1c, 0x1f, 0xf6, 0x37, 0xf4, 0xd7, 0xf4, 0xf2, 0x77, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x5c, 0x38, 0x3f, 0x45, 0xaf, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LocalWorkerServiceClient is the client API for LocalWorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LocalWorkerServiceClient interface {
	// Ping messages are send at regular intervals by local workers
	// as a heartbeat notification, as well as providing information about
	// versions.
	Ping(ctx context.Context, in *LocalWorkerInfo, opts ...grpc.CallOption) (*Empty, error)
	// GetPowerRequests is used to get a stream of power requests from the network
	// master.
	GetPowerRequests(ctx context.Context, in *PowerRequestsOptions, opts ...grpc.CallOption) (LocalWorkerService_GetPowerRequestsClient, error)
	// SetPowerActuals is used to send a stream of actual power statuses to
	// the network master.
	SetPowerActuals(ctx context.Context, opts ...grpc.CallOption) (LocalWorkerService_SetPowerActualsClient, error)
	// GetLocRequests is used to get a stream of loc requests from the network
	// master.
	GetLocRequests(ctx context.Context, in *LocRequestsOptions, opts ...grpc.CallOption) (LocalWorkerService_GetLocRequestsClient, error)
	// SetLocActuals is used to send a stream of actual loc statuses to
	// the network master.
	SetLocActuals(ctx context.Context, opts ...grpc.CallOption) (LocalWorkerService_SetLocActualsClient, error)
}

type localWorkerServiceClient struct {
	cc *grpc.ClientConn
}

func NewLocalWorkerServiceClient(cc *grpc.ClientConn) LocalWorkerServiceClient {
	return &localWorkerServiceClient{cc}
}

func (c *localWorkerServiceClient) Ping(ctx context.Context, in *LocalWorkerInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/binkynet.localworker.v1.LocalWorkerService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localWorkerServiceClient) GetPowerRequests(ctx context.Context, in *PowerRequestsOptions, opts ...grpc.CallOption) (LocalWorkerService_GetPowerRequestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LocalWorkerService_serviceDesc.Streams[0], "/binkynet.localworker.v1.LocalWorkerService/GetPowerRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &localWorkerServiceGetPowerRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocalWorkerService_GetPowerRequestsClient interface {
	Recv() (*Power, error)
	grpc.ClientStream
}

type localWorkerServiceGetPowerRequestsClient struct {
	grpc.ClientStream
}

func (x *localWorkerServiceGetPowerRequestsClient) Recv() (*Power, error) {
	m := new(Power)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *localWorkerServiceClient) SetPowerActuals(ctx context.Context, opts ...grpc.CallOption) (LocalWorkerService_SetPowerActualsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LocalWorkerService_serviceDesc.Streams[1], "/binkynet.localworker.v1.LocalWorkerService/SetPowerActuals", opts...)
	if err != nil {
		return nil, err
	}
	x := &localWorkerServiceSetPowerActualsClient{stream}
	return x, nil
}

type LocalWorkerService_SetPowerActualsClient interface {
	Send(*Power) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type localWorkerServiceSetPowerActualsClient struct {
	grpc.ClientStream
}

func (x *localWorkerServiceSetPowerActualsClient) Send(m *Power) error {
	return x.ClientStream.SendMsg(m)
}

func (x *localWorkerServiceSetPowerActualsClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *localWorkerServiceClient) GetLocRequests(ctx context.Context, in *LocRequestsOptions, opts ...grpc.CallOption) (LocalWorkerService_GetLocRequestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LocalWorkerService_serviceDesc.Streams[2], "/binkynet.localworker.v1.LocalWorkerService/GetLocRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &localWorkerServiceGetLocRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocalWorkerService_GetLocRequestsClient interface {
	Recv() (*Loc, error)
	grpc.ClientStream
}

type localWorkerServiceGetLocRequestsClient struct {
	grpc.ClientStream
}

func (x *localWorkerServiceGetLocRequestsClient) Recv() (*Loc, error) {
	m := new(Loc)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *localWorkerServiceClient) SetLocActuals(ctx context.Context, opts ...grpc.CallOption) (LocalWorkerService_SetLocActualsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LocalWorkerService_serviceDesc.Streams[3], "/binkynet.localworker.v1.LocalWorkerService/SetLocActuals", opts...)
	if err != nil {
		return nil, err
	}
	x := &localWorkerServiceSetLocActualsClient{stream}
	return x, nil
}

type LocalWorkerService_SetLocActualsClient interface {
	Send(*Loc) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type localWorkerServiceSetLocActualsClient struct {
	grpc.ClientStream
}

func (x *localWorkerServiceSetLocActualsClient) Send(m *Loc) error {
	return x.ClientStream.SendMsg(m)
}

func (x *localWorkerServiceSetLocActualsClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LocalWorkerServiceServer is the server API for LocalWorkerService service.
type LocalWorkerServiceServer interface {
	// Ping messages are send at regular intervals by local workers
	// as a heartbeat notification, as well as providing information about
	// versions.
	Ping(context.Context, *LocalWorkerInfo) (*Empty, error)
	// GetPowerRequests is used to get a stream of power requests from the network
	// master.
	GetPowerRequests(*PowerRequestsOptions, LocalWorkerService_GetPowerRequestsServer) error
	// SetPowerActuals is used to send a stream of actual power statuses to
	// the network master.
	SetPowerActuals(LocalWorkerService_SetPowerActualsServer) error
	// GetLocRequests is used to get a stream of loc requests from the network
	// master.
	GetLocRequests(*LocRequestsOptions, LocalWorkerService_GetLocRequestsServer) error
	// SetLocActuals is used to send a stream of actual loc statuses to
	// the network master.
	SetLocActuals(LocalWorkerService_SetLocActualsServer) error
}

func RegisterLocalWorkerServiceServer(s *grpc.Server, srv LocalWorkerServiceServer) {
	s.RegisterService(&_LocalWorkerService_serviceDesc, srv)
}

func _LocalWorkerService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalWorkerInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalWorkerServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/binkynet.localworker.v1.LocalWorkerService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalWorkerServiceServer).Ping(ctx, req.(*LocalWorkerInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalWorkerService_GetPowerRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PowerRequestsOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocalWorkerServiceServer).GetPowerRequests(m, &localWorkerServiceGetPowerRequestsServer{stream})
}

type LocalWorkerService_GetPowerRequestsServer interface {
	Send(*Power) error
	grpc.ServerStream
}

type localWorkerServiceGetPowerRequestsServer struct {
	grpc.ServerStream
}

func (x *localWorkerServiceGetPowerRequestsServer) Send(m *Power) error {
	return x.ServerStream.SendMsg(m)
}

func _LocalWorkerService_SetPowerActuals_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LocalWorkerServiceServer).SetPowerActuals(&localWorkerServiceSetPowerActualsServer{stream})
}

type LocalWorkerService_SetPowerActualsServer interface {
	SendAndClose(*Empty) error
	Recv() (*Power, error)
	grpc.ServerStream
}

type localWorkerServiceSetPowerActualsServer struct {
	grpc.ServerStream
}

func (x *localWorkerServiceSetPowerActualsServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *localWorkerServiceSetPowerActualsServer) Recv() (*Power, error) {
	m := new(Power)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LocalWorkerService_GetLocRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LocRequestsOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocalWorkerServiceServer).GetLocRequests(m, &localWorkerServiceGetLocRequestsServer{stream})
}

type LocalWorkerService_GetLocRequestsServer interface {
	Send(*Loc) error
	grpc.ServerStream
}

type localWorkerServiceGetLocRequestsServer struct {
	grpc.ServerStream
}

func (x *localWorkerServiceGetLocRequestsServer) Send(m *Loc) error {
	return x.ServerStream.SendMsg(m)
}

func _LocalWorkerService_SetLocActuals_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LocalWorkerServiceServer).SetLocActuals(&localWorkerServiceSetLocActualsServer{stream})
}

type LocalWorkerService_SetLocActualsServer interface {
	SendAndClose(*Empty) error
	Recv() (*Loc, error)
	grpc.ServerStream
}

type localWorkerServiceSetLocActualsServer struct {
	grpc.ServerStream
}

func (x *localWorkerServiceSetLocActualsServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *localWorkerServiceSetLocActualsServer) Recv() (*Loc, error) {
	m := new(Loc)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _LocalWorkerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "binkynet.localworker.v1.LocalWorkerService",
	HandlerType: (*LocalWorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _LocalWorkerService_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetPowerRequests",
			Handler:       _LocalWorkerService_GetPowerRequests_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetPowerActuals",
			Handler:       _LocalWorkerService_SetPowerActuals_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetLocRequests",
			Handler:       _LocalWorkerService_GetLocRequests_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetLocActuals",
			Handler:       _LocalWorkerService_SetLocActuals_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "localworker.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalWorkerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalWorkerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Uptime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(m.Uptime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PowerRequestsOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PowerRequestsOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ManualConfirm {
		dAtA[i] = 0x8
		i++
		if m.ManualConfirm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Power) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Power) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocRequestsOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocRequestsOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ManualConfirm {
		dAtA[i] = 0x8
		i++
		if m.ManualConfirm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Loc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Speed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(m.Speed))
	}
	if m.SpeedSteps != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(m.SpeedSteps))
	}
	if m.Direction != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLocalworker(dAtA, i, uint64(m.Direction))
	}
	if len(m.Functions) > 0 {
		for k, _ := range m.Functions {
			dAtA[i] = 0x2a
			i++
			v := m.Functions[k]
			mapSize := 1 + sovLocalworker(uint64(k)) + 1 + 1
			i = encodeVarintLocalworker(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintLocalworker(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintLocalworker(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalWorkerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLocalworker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLocalworker(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovLocalworker(uint64(l))
	}
	if m.Uptime != 0 {
		n += 1 + sovLocalworker(uint64(m.Uptime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PowerRequestsOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualConfirm {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Power) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocRequestsOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualConfirm {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Loc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovLocalworker(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovLocalworker(uint64(m.Speed))
	}
	if m.SpeedSteps != 0 {
		n += 1 + sovLocalworker(uint64(m.SpeedSteps))
	}
	if m.Direction != 0 {
		n += 1 + sovLocalworker(uint64(m.Direction))
	}
	if len(m.Functions) > 0 {
		for k, v := range m.Functions {
			_ = k
			_ = v
			mapEntrySize := 1 + sovLocalworker(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovLocalworker(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLocalworker(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLocalworker(x uint64) (n int) {
	return sovLocalworker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLocalworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalWorkerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalWorkerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalWorkerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocalworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PowerRequestsOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PowerRequestsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PowerRequestsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualConfirm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ManualConfirm = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocalworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Power) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Power: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Power: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocalworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocRequestsOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocRequestsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocRequestsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualConfirm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ManualConfirm = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocalworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedSteps", wireType)
			}
			m.SpeedSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedSteps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= LocDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Functions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalworker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Functions == nil {
				m.Functions = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalworker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalworker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalworker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalworker(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLocalworker
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Functions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocalworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLocalworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocalworker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocalworker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalworker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocalworker
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLocalworker
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLocalworker
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLocalworker(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLocalworker
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLocalworker = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocalworker   = fmt.Errorf("proto: integer overflow")
)
