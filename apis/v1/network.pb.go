// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: network.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("network.proto", fileDescriptor_8571034d60397816) }

var fileDescriptor_8571034d60397816 = []byte{
	// 282 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0xd1, 0xc1, 0x4a, 0xc3, 0x30,
	0x1c, 0x06, 0x70, 0x33, 0x9c, 0x93, 0x0c, 0x61, 0x44, 0x44, 0xc8, 0xa1, 0x27, 0x0f, 0x9e, 0xd2,
	0xcd, 0x09, 0xee, 0xea, 0x86, 0x07, 0x61, 0x4c, 0xa1, 0xe0, 0xc1, 0xdb, 0x1a, 0x82, 0x0b, 0xdd,
	0xfa, 0x0f, 0xc9, 0xbf, 0x2d, 0x7d, 0x13, 0x9f, 0xc1, 0x27, 0xf1, 0xe8, 0x1b, 0x28, 0xf5, 0x45,
	0x64, 0x29, 0x03, 0xbb, 0xf5, 0x56, 0x7e, 0xdf, 0xf7, 0x35, 0x81, 0xd0, 0xb3, 0x54, 0x61, 0x01,
	0x36, 0x11, 0xc6, 0x02, 0x02, 0xeb, 0xc7, 0x3a, 0x4d, 0xca, 0x54, 0xa1, 0xc8, 0x47, 0xbc, 0x8f,
	0xa5, 0x51, 0xae, 0x4e, 0x6e, 0xbe, 0x3b, 0xf4, 0x62, 0x51, 0x77, 0x67, 0x90, 0xa2, 0x85, 0x75,
	0xa4, 0x6c, 0xae, 0xa5, 0x62, 0x13, 0xda, 0x7d, 0x86, 0x42, 0x59, 0x76, 0x29, 0xfe, 0xad, 0x85,
	0xb7, 0x08, 0x97, 0xa8, 0x38, 0x3b, 0x0c, 0xae, 0xc9, 0x90, 0x30, 0x41, 0x8f, 0xe7, 0x20, 0x1d,
	0x1b, 0x34, 0xf2, 0x39, 0x48, 0x7e, 0x20, 0xbe, 0x7f, 0x4b, 0x7b, 0x91, 0x4a, 0x1d, 0x58, 0xc7,
	0x9a, 0xbf, 0x7c, 0xd8, 0x18, 0x2c, 0xf9, 0x79, 0xc3, 0xea, 0xe6, 0x90, 0xb0, 0x3b, 0xda, 0x7b,
	0xca, 0xd0, 0x64, 0xe8, 0x58, 0xb3, 0x51, 0x2b, 0x6f, 0x43, 0x7f, 0xdc, 0x84, 0x9e, 0x46, 0x85,
	0x46, 0xb9, 0x52, 0xfb, 0xcb, 0x9a, 0x79, 0x1b, 0xfa, 0xe5, 0x98, 0x76, 0x67, 0x6b, 0x90, 0xc9,
	0xde, 0x35, 0xbd, 0xf1, 0x16, 0xdb, 0x8e, 0xa6, 0x8f, 0x9f, 0x55, 0x40, 0xbe, 0xaa, 0x80, 0xfc,
	0x54, 0x01, 0x79, 0xff, 0x0d, 0x8e, 0x5e, 0xaf, 0xde, 0x34, 0xae, 0xb2, 0x58, 0x48, 0xd8, 0x84,
	0xbb, 0x4d, 0x38, 0xdd, 0x7e, 0x2c, 0x14, 0x86, 0x4b, 0xa3, 0x5d, 0x98, 0x8f, 0x3e, 0x3a, 0x83,
	0x1d, 0x89, 0x7b, 0xa3, 0x9d, 0x78, 0x19, 0xc5, 0x27, 0xfe, 0xcd, 0xc6, 0x7f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x2e, 0xd2, 0xa6, 0x8d, 0xde, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NetworkControlServiceClient is the client API for NetworkControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NetworkControlServiceClient interface {
	// Power is used to send power requests and receive power request & actual changes.
	Power(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_PowerClient, error)
	// Locs is used to control locs and get changes in loc requests & actual state back.
	// Note: Loc.actual on incoming objects is ignored.
	Locs(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_LocsClient, error)
	// Sensors is used to receive a stream of actual sensor states.
	Sensors(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NetworkControlService_SensorsClient, error)
	// Outputs is used to control outputs and get changes in output requests & actual state back.
	// Note: Output.actual on incoming objects is ignored.
	Outputs(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_OutputsClient, error)
	// Switches is used to control switches and get changes in switch requests & actual state back.
	// Note: Switche.actual on incoming objects is ignored.
	Switches(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_SwitchesClient, error)
	// Clock is used to send clock requests and receive clock changes.
	Clock(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_ClockClient, error)
}

type networkControlServiceClient struct {
	cc *grpc.ClientConn
}

func NewNetworkControlServiceClient(cc *grpc.ClientConn) NetworkControlServiceClient {
	return &networkControlServiceClient{cc}
}

func (c *networkControlServiceClient) Power(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_PowerClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkControlService_serviceDesc.Streams[0], "/binkynet.v1.NetworkControlService/Power", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkControlServicePowerClient{stream}
	return x, nil
}

type NetworkControlService_PowerClient interface {
	Send(*PowerState) error
	Recv() (*Power, error)
	grpc.ClientStream
}

type networkControlServicePowerClient struct {
	grpc.ClientStream
}

func (x *networkControlServicePowerClient) Send(m *PowerState) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkControlServicePowerClient) Recv() (*Power, error) {
	m := new(Power)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkControlServiceClient) Locs(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_LocsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkControlService_serviceDesc.Streams[1], "/binkynet.v1.NetworkControlService/Locs", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkControlServiceLocsClient{stream}
	return x, nil
}

type NetworkControlService_LocsClient interface {
	Send(*Loc) error
	Recv() (*Loc, error)
	grpc.ClientStream
}

type networkControlServiceLocsClient struct {
	grpc.ClientStream
}

func (x *networkControlServiceLocsClient) Send(m *Loc) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkControlServiceLocsClient) Recv() (*Loc, error) {
	m := new(Loc)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkControlServiceClient) Sensors(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NetworkControlService_SensorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkControlService_serviceDesc.Streams[2], "/binkynet.v1.NetworkControlService/Sensors", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkControlServiceSensorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkControlService_SensorsClient interface {
	Recv() (*Sensor, error)
	grpc.ClientStream
}

type networkControlServiceSensorsClient struct {
	grpc.ClientStream
}

func (x *networkControlServiceSensorsClient) Recv() (*Sensor, error) {
	m := new(Sensor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkControlServiceClient) Outputs(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_OutputsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkControlService_serviceDesc.Streams[3], "/binkynet.v1.NetworkControlService/Outputs", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkControlServiceOutputsClient{stream}
	return x, nil
}

type NetworkControlService_OutputsClient interface {
	Send(*Output) error
	Recv() (*Output, error)
	grpc.ClientStream
}

type networkControlServiceOutputsClient struct {
	grpc.ClientStream
}

func (x *networkControlServiceOutputsClient) Send(m *Output) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkControlServiceOutputsClient) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkControlServiceClient) Switches(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_SwitchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkControlService_serviceDesc.Streams[4], "/binkynet.v1.NetworkControlService/Switches", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkControlServiceSwitchesClient{stream}
	return x, nil
}

type NetworkControlService_SwitchesClient interface {
	Send(*Switch) error
	Recv() (*Switch, error)
	grpc.ClientStream
}

type networkControlServiceSwitchesClient struct {
	grpc.ClientStream
}

func (x *networkControlServiceSwitchesClient) Send(m *Switch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkControlServiceSwitchesClient) Recv() (*Switch, error) {
	m := new(Switch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkControlServiceClient) Clock(ctx context.Context, opts ...grpc.CallOption) (NetworkControlService_ClockClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkControlService_serviceDesc.Streams[5], "/binkynet.v1.NetworkControlService/Clock", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkControlServiceClockClient{stream}
	return x, nil
}

type NetworkControlService_ClockClient interface {
	Send(*Clock) error
	Recv() (*Clock, error)
	grpc.ClientStream
}

type networkControlServiceClockClient struct {
	grpc.ClientStream
}

func (x *networkControlServiceClockClient) Send(m *Clock) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkControlServiceClockClient) Recv() (*Clock, error) {
	m := new(Clock)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NetworkControlServiceServer is the server API for NetworkControlService service.
type NetworkControlServiceServer interface {
	// Power is used to send power requests and receive power request & actual changes.
	Power(NetworkControlService_PowerServer) error
	// Locs is used to control locs and get changes in loc requests & actual state back.
	// Note: Loc.actual on incoming objects is ignored.
	Locs(NetworkControlService_LocsServer) error
	// Sensors is used to receive a stream of actual sensor states.
	Sensors(*Empty, NetworkControlService_SensorsServer) error
	// Outputs is used to control outputs and get changes in output requests & actual state back.
	// Note: Output.actual on incoming objects is ignored.
	Outputs(NetworkControlService_OutputsServer) error
	// Switches is used to control switches and get changes in switch requests & actual state back.
	// Note: Switche.actual on incoming objects is ignored.
	Switches(NetworkControlService_SwitchesServer) error
	// Clock is used to send clock requests and receive clock changes.
	Clock(NetworkControlService_ClockServer) error
}

// UnimplementedNetworkControlServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNetworkControlServiceServer struct {
}

func (*UnimplementedNetworkControlServiceServer) Power(srv NetworkControlService_PowerServer) error {
	return status.Errorf(codes.Unimplemented, "method Power not implemented")
}
func (*UnimplementedNetworkControlServiceServer) Locs(srv NetworkControlService_LocsServer) error {
	return status.Errorf(codes.Unimplemented, "method Locs not implemented")
}
func (*UnimplementedNetworkControlServiceServer) Sensors(req *Empty, srv NetworkControlService_SensorsServer) error {
	return status.Errorf(codes.Unimplemented, "method Sensors not implemented")
}
func (*UnimplementedNetworkControlServiceServer) Outputs(srv NetworkControlService_OutputsServer) error {
	return status.Errorf(codes.Unimplemented, "method Outputs not implemented")
}
func (*UnimplementedNetworkControlServiceServer) Switches(srv NetworkControlService_SwitchesServer) error {
	return status.Errorf(codes.Unimplemented, "method Switches not implemented")
}
func (*UnimplementedNetworkControlServiceServer) Clock(srv NetworkControlService_ClockServer) error {
	return status.Errorf(codes.Unimplemented, "method Clock not implemented")
}

func RegisterNetworkControlServiceServer(s *grpc.Server, srv NetworkControlServiceServer) {
	s.RegisterService(&_NetworkControlService_serviceDesc, srv)
}

func _NetworkControlService_Power_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkControlServiceServer).Power(&networkControlServicePowerServer{stream})
}

type NetworkControlService_PowerServer interface {
	Send(*Power) error
	Recv() (*PowerState, error)
	grpc.ServerStream
}

type networkControlServicePowerServer struct {
	grpc.ServerStream
}

func (x *networkControlServicePowerServer) Send(m *Power) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkControlServicePowerServer) Recv() (*PowerState, error) {
	m := new(PowerState)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NetworkControlService_Locs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkControlServiceServer).Locs(&networkControlServiceLocsServer{stream})
}

type NetworkControlService_LocsServer interface {
	Send(*Loc) error
	Recv() (*Loc, error)
	grpc.ServerStream
}

type networkControlServiceLocsServer struct {
	grpc.ServerStream
}

func (x *networkControlServiceLocsServer) Send(m *Loc) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkControlServiceLocsServer) Recv() (*Loc, error) {
	m := new(Loc)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NetworkControlService_Sensors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkControlServiceServer).Sensors(m, &networkControlServiceSensorsServer{stream})
}

type NetworkControlService_SensorsServer interface {
	Send(*Sensor) error
	grpc.ServerStream
}

type networkControlServiceSensorsServer struct {
	grpc.ServerStream
}

func (x *networkControlServiceSensorsServer) Send(m *Sensor) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkControlService_Outputs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkControlServiceServer).Outputs(&networkControlServiceOutputsServer{stream})
}

type NetworkControlService_OutputsServer interface {
	Send(*Output) error
	Recv() (*Output, error)
	grpc.ServerStream
}

type networkControlServiceOutputsServer struct {
	grpc.ServerStream
}

func (x *networkControlServiceOutputsServer) Send(m *Output) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkControlServiceOutputsServer) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NetworkControlService_Switches_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkControlServiceServer).Switches(&networkControlServiceSwitchesServer{stream})
}

type NetworkControlService_SwitchesServer interface {
	Send(*Switch) error
	Recv() (*Switch, error)
	grpc.ServerStream
}

type networkControlServiceSwitchesServer struct {
	grpc.ServerStream
}

func (x *networkControlServiceSwitchesServer) Send(m *Switch) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkControlServiceSwitchesServer) Recv() (*Switch, error) {
	m := new(Switch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NetworkControlService_Clock_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkControlServiceServer).Clock(&networkControlServiceClockServer{stream})
}

type NetworkControlService_ClockServer interface {
	Send(*Clock) error
	Recv() (*Clock, error)
	grpc.ServerStream
}

type networkControlServiceClockServer struct {
	grpc.ServerStream
}

func (x *networkControlServiceClockServer) Send(m *Clock) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkControlServiceClockServer) Recv() (*Clock, error) {
	m := new(Clock)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _NetworkControlService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "binkynet.v1.NetworkControlService",
	HandlerType: (*NetworkControlServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Power",
			Handler:       _NetworkControlService_Power_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Locs",
			Handler:       _NetworkControlService_Locs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Sensors",
			Handler:       _NetworkControlService_Sensors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Outputs",
			Handler:       _NetworkControlService_Outputs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Switches",
			Handler:       _NetworkControlService_Switches_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Clock",
			Handler:       _NetworkControlService_Clock_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "network.proto",
}
